(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{463:function(v,s,e){"use strict";e.r(s);var _=e(2),i=Object(_.a)({},(function(){var v=this,s=v._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("p",[v._v("使用缓存的时候，我们经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了做数据同步（比如 Redis 集群的主从节点通过 RDB 文件同步数据）。\nRedis 支持 3 种持久化方式:")]),v._v(" "),s("ul",[s("li",[v._v("快照（snapshotting，RDB）")]),v._v(" "),s("li",[v._v("只追加文件（append-only file, AOF）")]),v._v(" "),s("li",[v._v("RDB 和 AOF 的混合持久化(Redis 4.0 新增)")])]),v._v(" "),s("h1",{attrs:{id:"rdb快照"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rdb快照"}},[v._v("#")]),v._v(" RDB快照")]),v._v(" "),s("p",[v._v("Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：")]),v._v(" "),s("ul",[s("li",[v._v("执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，会阻塞主线程；")]),v._v(" "),s("li",[v._v("执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以避免主线程的阻塞；")])]),v._v(" "),s("p",[v._v("Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，"),s("strong",[v._v("注意不是save")]),v._v("，默认会提供以下配置：")]),v._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[v._v("save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。\n\nsave 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。\n\nsave 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。\n\n")])])]),s("p",[v._v("执行 bgsave 过程中，由于是交给子进程来构建 RDB 文件，主线程还是可以继续工作的，Redis 依然可以继续处理操作命令，也就是数据是能被修改的。关键的技术就在于写时复制技术（Copy-On-Write, COW）。")]),v._v(" "),s("p",[v._v("执行 bgsave 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个。")]),v._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/c34a9d1f58d602ff1fe8601f7270baa7.png",alt:"只读"}})]),v._v(" "),s("p",[v._v("只有在发生修改内存数据的情况时，物理内存才会被复制一份。")]),v._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/ebd620db8a1af66fbeb8f4d4ef6adc68.png",alt:"写"}})]),v._v(" "),s("p",[v._v("这个过程有个问题，bgsave 快照过程中，如果主线程修改了共享数据，发生了写时复制后，RDB 快照保存的是原本的内存数据，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照。")]),v._v(" "),s("p",[v._v("RDB 文件的加载工作是在服务器启动时自动执行的，Redis 并没有提供专门用于加载 RDB 文件的命令。")]),v._v(" "),s("h1",{attrs:{id:"aof"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof"}},[v._v("#")]),v._v(" AOF")]),v._v(" "),s("p",[v._v("Redis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里，然后重启 Redis 的时候，先去读取这个文件里的命令，并且执行它，就相当于恢复了缓存数据。这种保存写操作命令到日志的持久化方式，就是 Redis 里的 AOF(Append Only File) 持久化功能，注意只会记录写操作命令，读操作命令是不会被记录的，因为没意义。")]),v._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/6f0ab40396b7fc2c15e6f4487d3a0ad7.png",alt:"AOF"}})]),v._v(" "),s("p",[v._v("注意顺序先执行写操作再记录命令到日志，原因有两个：")]),v._v(" "),s("ol",[s("li",[v._v("避免额外的检查开销。只有在该命令执行成功后，才将命令记录到 AOF 日志里。如果当前的命令语法有问题，就不会存入AOF日志，保证记录在 AOF 日志里的命令都是可执行并且正确的。")]),v._v(" "),s("li",[v._v("不会阻塞当前写操作命令的执行，因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。")])]),v._v(" "),s("p",[v._v("但是也存在风险：")]),v._v(" "),s("ol",[s("li",[s("p",[v._v("执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。")])]),v._v(" "),s("li",[s("p",[v._v("由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是可能会给「下一个」命令带来阻塞风险。因为将命令写入到日志的这个操作也是在主进程完成的（执行命令也是在主进程），也就是说这两个操作是同步的,因为写日志到硬盘的速度很慢，会一直阻塞在当前进程，可能会导致后续的命令无法执行。\n这两个风险都跟「 AOF 日志写回硬盘的时机」有关。第一个是写AOF日志太慢不及时，第二个是写的太频繁影响主进程。写回硬盘的时机下边分析。")])])]),v._v(" "),s("p",[v._v("AOF 持久化功能的实现可以简单分为 5 步：")]),v._v(" "),s("ol",[s("li",[v._v("命令追加（append）：所有的写命令会追加到 AOF 缓冲区中。")]),v._v(" "),s("li",[v._v("文件写入（write）：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用write函数（系统调用），write将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。")]),v._v(" "),s("li",[v._v("文件同步（fsync）：AOF 缓冲区根据对应的持久化方式（ fsync 策略）向硬盘做同步操作。这一步需要调用 fsync 函数（系统调用）， fsync 针对单个文件操作，对其进行强制硬盘同步，fsync 将阻塞直到写入磁盘完成后返回，保证了数据持久化。")]),v._v(" "),s("li",[v._v("文件重写（rewrite）：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。")]),v._v(" "),s("li",[v._v("重启加载（load）：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。")])]),v._v(" "),s("p",[v._v("这里对上面提到的一些 Linux 系统调用再做一遍解释：")]),v._v(" "),s("ul",[s("li",[v._v("write：写入系统内核缓冲区之后直接返回（仅仅是写到缓冲区），不会立即同步到硬盘。虽然提高了效率，但也带来了数据丢失的风险。同步硬盘操作通常依赖于系统调度机制，Linux 内核通常为 30s 同步一次，具体值取决于写出的数据量和 I/O 缓冲区的状态。")]),v._v(" "),s("li",[v._v("fsync：fsync用于强制刷新系统内核缓冲区（同步到到磁盘），确保写磁盘操作结束才会返回。")])]),v._v(" "),s("p",[v._v("在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ fsync策略），它们分别是：")]),v._v(" "),s("ol",[s("li",[v._v("appendfsync always：主线程调用 write 执行写操作后，后台线程（ aof_fsync 线程）立即会调用 fsync 函数同步 AOF 文件（刷盘），fsync 完成后线程返回，这样会严重降低 Redis 的性能（write + fsync）。")]),v._v(" "),s("li",[v._v("appendfsync everysec：主线程调用 write 执行写操作后立即返回，由后台线程（ aof_fsync 线程）每秒钟调用 fsync 函数（系统调用）同步一次 AOF 文件（write+fsync，fsync间隔为 1 秒）")]),v._v(" "),s("li",[v._v("appendfsync no：主线程调用 write 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（write但不fsync，fsync 的时机由操作系统决定）。")])]),v._v(" "),s("p",[v._v("为了兼顾数据和写入性能，可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能受到的影响较小。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。")]),v._v(" "),s("h1",{attrs:{id:"rdb和aof混合持久化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rdb和aof混合持久化"}},[v._v("#")]),v._v(" RDB和AOF混合持久化")]),v._v(" "),s("p",[v._v("RDB 比 AOF 优秀的地方：")]),v._v(" "),s("ul",[s("li",[v._v("RDB 文件存储的内容是经过压缩的二进制数据， 文件很小。AOF 文件存储的是每一次写命令，通常会比 RDB 文件大很多。")]),v._v(" "),s("li",[v._v("与 AOF 相比，恢复大数据集的时候，RDB 速度更快。")])]),v._v(" "),s("p",[v._v("AOF 比 RDB 优秀的地方：")]),v._v(" "),s("ul",[s("li",[v._v("RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。")]),v._v(" "),s("li",[v._v("RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。")]),v._v(" "),s("li",[v._v("AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行FLUSHALL命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。")])]),v._v(" "),s("p",[v._v("Redis 4.0 开始支持 RDB 和 AOF 的混合持久化。混合持久化工作在 AOF 日志重写过程。当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。")]),v._v(" "),s("p",[v._v("也就是说，使用了混合持久化，AOF 文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据。这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样加载的时候速度会很快。加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得数据更少的丢失。")])])}),[],!1,null,null,null);s.default=i.exports}}]);