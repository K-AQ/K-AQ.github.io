(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{462:function(t,a,_){"use strict";_.r(a);var r=_(2),s=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"一、-抽象类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、-抽象类"}},[t._v("#")]),t._v(" 一、 抽象类")]),t._v(" "),a("p",[t._v("关键字：abstract")]),t._v(" "),a("h2",{attrs:{id:"_1-1-抽象类概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-抽象类概念"}},[t._v("#")]),t._v(" 1.1 抽象类概念")]),t._v(" "),a("ol",[a("li",[t._v("一个方法无法给出具体明确的，该方法可以声明为抽象方法")]),t._v(" "),a("li",[t._v("拥有抽象类方法的类，叫做抽象类")])]),t._v(" "),a("h2",{attrs:{id:"_1-2-抽象类特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-抽象类特点"}},[t._v("#")]),t._v(" 1.2 抽象类特点")]),t._v(" "),a("ol",[a("li",[t._v("继承了抽象类的子类，要么对父类的抽象方法进行重写，要么自己也是抽象类")]),t._v(" "),a("li",[t._v("抽象类也可以拥有普通方法")]),t._v(" "),a("li",[t._v("抽象类不能创建对象")]),t._v(" "),a("li",[t._v("抽象类也有构造方法，但是是为了子类创建对象使用")])]),t._v(" "),a("h2",{attrs:{id:"_1-3-抽象类存在价值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-抽象类存在价值"}},[t._v("#")]),t._v(" 1.3 抽象类存在价值")]),t._v(" "),a("p",[t._v("模板模式：由于抽象类既能拥有普通的方法，又有抽象的方法，这样，抽象类既能自己完成一些功能，又给子类提供无限的可能。")]),t._v(" "),a("h1",{attrs:{id:"二、-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、-接口"}},[t._v("#")]),t._v(" 二、 接口")]),t._v(" "),a("p",[t._v("关键字：interface")]),t._v(" "),a("h2",{attrs:{id:"_2-1-接口的概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-接口的概念"}},[t._v("#")]),t._v(" 2.1 接口的概念")]),t._v(" "),a("p",[t._v("算是一种特殊的抽象类，为了定义某种标准")]),t._v(" "),a("h2",{attrs:{id:"_2-2-接口的特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-接口的特点"}},[t._v("#")]),t._v(" 2.2 接口的特点")]),t._v(" "),a("ol",[a("li",[t._v("不能实例化")]),t._v(" "),a("li",[t._v("没有构造方法")]),t._v(" "),a("li",[t._v("方法默认public abstract修饰")]),t._v(" "),a("li",[t._v("变量默认public static final修饰")])]),t._v(" "),a("h2",{attrs:{id:"_2-3-接口存在价值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-接口存在价值"}},[t._v("#")]),t._v(" 2.3 接口存在价值")]),t._v(" "),a("ol",[a("li",[t._v("定义了规则：一个类可以同时实现多个接口")]),t._v(" "),a("li",[t._v("拓展了程序")])]),t._v(" "),a("h1",{attrs:{id:"_3-接口和抽象类的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-接口和抽象类的关系"}},[t._v("#")]),t._v(" 3 接口和抽象类的关系")]),t._v(" "),a("h2",{attrs:{id:"_3-1-接口和抽象类相同点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-接口和抽象类相同点"}},[t._v("#")]),t._v(" 3.1 接口和抽象类相同点")]),t._v(" "),a("p",[t._v("都是不断抽取出来的抽象概念")]),t._v(" "),a("h2",{attrs:{id:"_3-2-接口和抽象类的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-接口和抽象类的区别"}},[t._v("#")]),t._v(" 3.2 接口和抽象类的区别")]),t._v(" "),a("ol",[a("li",[t._v("接口是行为的抽象，是一种行为的规范，接口是like a 的关系；抽象是对类的抽象，是一种模板设计，抽象类是is a 的关系。")]),t._v(" "),a("li",[t._v("接口没有构造方法，而抽象类有构造方法，其方法一般给子类使用")]),t._v(" "),a("li",[t._v("接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。")]),t._v(" "),a("li",[t._v("抽象体现出了继承关系，继承只能单继承。接口提现出来了实现的关系，实现可以多实现。接口强调特定功能的实现，而抽象类强调所属关系。")]),t._v(" "),a("li",[t._v("接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。")])]),t._v(" "),a("p",[a("strong",[t._v("注意：JDK1.8中对接口增加了新的特性：")]),t._v("\n（1）默认方法（default method）：JDK 1.8允许给接口添加非抽象的方法实现，但必须使用default关键字修饰；定义了default的方法可以不被实现子类所实现，但只能被实现子类的对象调用；如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法；（2）静态方法（static method）：JDK 1.8中允许使用static关键字修饰一个方法，并提供实现，称为接口静态方法。接口静态方法只能通过接口调用（接口名.静态方法名）。")]),t._v(" "),a("h1",{attrs:{id:"参考博客"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考博客"}},[t._v("#")]),t._v(" 参考博客")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/Doreamonx/article/details/125673494",target:"_blank",rel:"noopener noreferrer"}},[t._v("抽象类和接口的区别（通俗易理解）"),a("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=s.exports}}]);