(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{466:function(a,t,s){"use strict";s.r(t);var e=s(2),r=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"什么是jwt"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是jwt"}},[a._v("#")]),a._v(" 什么是JWT")]),a._v(" "),t("p",[a._v("JWT （JSON Web Token） 是目前最流行的跨域认证解决方案，是一种基于 Token 的认证授权机制。 从 JWT 的全称可以看出，JWT 本身也是 Token，一种规范化之后的 JSON 结构的 Token。JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 Session 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。可以看出，JWT 更符合设计 RESTful API 时的「Stateless（无状态）」原则 。并且， 使用 JWT 认证可以有效避免 CSRF 攻击，因为 JWT 一般是存在 localStorage 中，使用 JWT 进行身份验证的过程中是不会涉及到 Cookie 的。")]),a._v(" "),t("h1",{attrs:{id:"jwt的组成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jwt的组成"}},[a._v("#")]),a._v(" JWT的组成")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://oss.javaguide.cn/javaguide/system-design/jwt/jwt-composition.png",alt:"JWT的组成"}})]),a._v(" "),t("p",[a._v("JWT 本质上就是一组字串，通过（.）切分成三个为 Base64 编码的部分：")]),a._v(" "),t("ul",[t("li",[a._v("Header : 描述 JWT 的元数据，定义了生成签名的算法以及 Token 的类型。")]),a._v(" "),t("li",[a._v("Payload : 用来存放实际需要传递的数据Signature（签名）：服务器通过")]),a._v(" "),t("li",[a._v("Payload、Header 和一个密钥(Secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。")])]),a._v(" "),t("p",[a._v("JWT 通常是这样的：xxxxx.yyyyy.zzzzz。示例：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\neyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.\nSflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n")])])]),t("p",[a._v("Header 和 Payload 都是 JSON 格式的数据，Signature 由 Payload、Header 和 Secret(密钥)通过特定的计算公式和加密算法得到。")]),a._v(" "),t("h2",{attrs:{id:"header"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#header"}},[a._v("#")]),a._v(" Header")]),a._v(" "),t("p",[a._v("Header 通常由两部分组成：")]),a._v(" "),t("ul",[t("li",[a._v("typ（Type）：令牌类型，也就是 JWT。")]),a._v(" "),t("li",[a._v("alg（Algorithm）：签名算法，比如 HS256。\n示例：")])]),a._v(" "),t("div",{staticClass:"language-json extra-class"},[t("pre",{pre:!0,attrs:{class:"language-json"}},[t("code",[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token property"}},[a._v('"alg"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"HS256"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token property"}},[a._v('"typ"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"JWT"')]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",[a._v("JSON 形式的 Header 被转换成 Base64 编码，成为 JWT 的第一部分。")]),a._v(" "),t("h2",{attrs:{id:"payload"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#payload"}},[a._v("#")]),a._v(" Payload")]),a._v(" "),t("p",[a._v("Payload 也是 JSON 格式数据，其中包含了 Claims(声明，包含 JWT 的相关信息)。Claims 分为三种类型：")]),a._v(" "),t("ul",[t("li",[a._v("Registered Claims（注册声明）：预定义的一些声明，建议使用，但不是强制性的。")]),a._v(" "),t("li",[a._v("Public Claims（公有声明）：JWT 签发方可以自定义的声明，但是为了避免冲突，应该在 IANA JSON Web Token Registryopen in new window 中定义它们。")]),a._v(" "),t("li",[a._v("Private Claims（私有声明）：JWT 签发方因为项目需要而自定义的声明，更符合实际项目场景使用。\n示例：")])]),a._v(" "),t("div",{staticClass:"language-json extra-class"},[t("pre",{pre:!0,attrs:{class:"language-json"}},[t("code",[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token property"}},[a._v('"uid"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"ff1212f5-d8d1-4496-bf41-d2dda73de19a"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token property"}},[a._v('"sub"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"1234567890"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token property"}},[a._v('"name"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"John Doe"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token property"}},[a._v('"exp"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("15323232")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token property"}},[a._v('"iat"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1516239022")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token property"}},[a._v('"scope"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"admin"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"user"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n")])])]),t("p",[a._v("Payload 部分默认是不加密的，"),t("strong",[a._v("一定不要将隐私信息存放在 Payload 当中")]),a._v("！！！JSON 形式的 Payload 被转换成 Base64 编码，成为 JWT 的第二部分。")]),a._v(" "),t("h2",{attrs:{id:"signature"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#signature"}},[a._v("#")]),a._v(" Signature")]),a._v(" "),t("p",[a._v("Signature 部分是对前两部分的签名，作用是防止 JWT（主要是 payload） 被篡改。这个签名的生成需要用到：Header + Payload。存放在服务端的密钥(一定不要泄露出去)。签名算法。签名的计算公式如下：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('HMACSHA256(\n  base64UrlEncode(header) + "." +\n  base64UrlEncode(payload),\n  secret)\n\n')])])]),t("p",[a._v('算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用"点"（.）分隔，这个字符串就是 JWT 。')]),a._v(" "),t("h1",{attrs:{id:"jwt身份验证过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jwt身份验证过程"}},[a._v("#")]),a._v(" JWT身份验证过程")]),a._v(" "),t("p",[a._v("在基于 JWT 进行身份验证的的应用程序中，服务器通过 Payload、Header 和 Secret(密钥)创建 JWT 并将 JWT 发送给客户端。客户端接收到 JWT 之后，会将其保存在 Cookie 或者 localStorage 里面，项目里是存在redis中，以后客户端发出的所有请求都会携带这个令牌。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://picture.gptkong.com/20240624/213248eb3471534fc8a4d18de43d08e130.png",alt:"JWT 身份验证示意图"}})]),a._v(" "),t("p",[a._v("步骤如下：")]),a._v(" "),t("ol",[t("li",[a._v("用户向服务器发送用户名、密码以及验证码用于登陆系统。")]),a._v(" "),t("li",[a._v("如果用户用户名、密码以及验证码校验正确的话，服务端会返回已经签名的 Token，也就是 JWT。")]),a._v(" "),t("li",[a._v("用户以后每次向后端发请求都在 Header 中带上这个 JWT 。")]),a._v(" "),t("li",[a._v("服务端检查 JWT 并从中获取用户相关信息。")])]),a._v(" "),t("h1",{attrs:{id:"如何防止jwt被篡改"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何防止jwt被篡改"}},[a._v("#")]),a._v(" 如何防止JWT被篡改")]),a._v(" "),t("p",[a._v("有了签名之后，即使 JWT 被泄露或者截获，黑客也没办法同时篡改 Signature、Header、Payload。这是为什么呢？因为服务端拿到 JWT 之后，会解析出其中包含的 Header、Payload 以及 Signature 。服务端会根据 Header、Payload、密钥再次生成一个 Signature。拿新生成的 Signature 和 JWT 中的 Signature 作对比，如果一样就说明 Header 和 Payload 没有被修改。不过，如果服务端的秘钥也被泄露的话，黑客就可以同时篡改 Signature、Header、Payload 了。黑客直接修改了 Header 和 Payload 之后，再重新生成一个 Signature 就可以了。密钥一定保管好，一定不要泄露出去。"),t("strong",[a._v("JWT 安全的核心在于签名，签名安全的核心在密钥。")])])])}),[],!1,null,null,null);t.default=r.exports}}]);